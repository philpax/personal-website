<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Abusing The C Preprocessor: Writing A 4-Bit Adder - Philpax</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="your friendly neighbourhood polyglot programmer&#x2F;engineer"/>

    <meta property="og:title" content="Philpax&nbsp;-&nbsp;Abusing The C Preprocessor: Writing A 4-Bit Adder" />
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https:&#x2F;&#x2F;philpax.me&#x2F;blog&#x2F;abusing-the-c-preprocessor&#x2F;"/>
    <meta property="og:description" content="I&#x27;ve always wondered what could be done with the C preprocessor. The existence of projects such as Boost Preprocessor and the infamous Brainfuck interpreter are a testament to its wide-ranging capabilâ€¦"/>
    <link rel="preload" href="https://philpax.me/assets/fonts/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="https://philpax.me/assets/fonts/FiraCode-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link rel="stylesheet" href="https://philpax.me/style.css?h=4ffdd54e7b066fbdcf280f65a4eb6f12bd85d1beeabddd9b2ae6f66585dc690b">
    <link rel="stylesheet" href="https://philpax.me/color/purple.css?h=af5472926e882590ce4fb43255caefd527646092b37417e3222375974bb7b6bb">
</head>
    <body>
        <div class="container center">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;">
    <div class="logo">
        philpax
    </div>
</a>
        </div>
        
    <ul class="menu__inner menu__inner--desktop">
        
        
                <li>
                    <a href="
    
        https://philpax.me
    
">blog</a>
                </li>
            
                <li>
                    <a href="
    
        https://philpax.me/tags
    
">tags</a>
                </li>
            
                <li>
                    <a href="
    
        https:&#x2F;&#x2F;github.com&#x2F;philpax
    
">github</a>
                </li>
            
                <li>
                    <a href="
    
        https:&#x2F;&#x2F;twitter.com&#x2F;philpax_
    
">twitter</a>
                </li>
            
                <li>
                    <a href="
    
        https://philpax.me/about
    
">about</a>
                </li>
            
        </ul>

        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        
    <ul class="menu__inner menu__inner--mobile">
        
        <li>
            <a href="
    
        https://philpax.me
    
">blog</a>
        </li>
        <li>
            <a href="
    
        https://philpax.me/tags
    
">tags</a>
        </li>
        <li>
            <a href="
    
        https:&#x2F;&#x2F;github.com&#x2F;philpax
    
">github</a>
        </li>
        <li>
            <a href="
    
        https:&#x2F;&#x2F;twitter.com&#x2F;philpax_
    
">twitter</a>
        </li>
        <li>
            <a href="
    
        https://philpax.me/about
    
">about</a>
        </li>
    </ul>

    </nav>

    </header>
<div class="content"><article class="post">
        
    <header>
        <div class="post-title">
            <div class="flex-container">
                <h1>
                    <a href="https:&#x2F;&#x2F;philpax.me&#x2F;blog&#x2F;abusing-the-c-preprocessor&#x2F;">Abusing The C Preprocessor: Writing A 4-Bit Adder</a>
                </h1>

                <span class="post-date">2013-10-01
                        <!---->
                </span>
            </div>

            <div class="meta">
                
    <div class="post-meta">
        

    
    <a href="https://philpax.me/tags/c/">#c</a>
        
    <a href="https://philpax.me/tags/cursed/">#cursed</a>
        
    
            
        
    </div>

            </div>
        </div>
    </header>
<p>I've always wondered what could be done with the C preprocessor. The existence of projects such as <a href="http://www.boost.org/doc/libs/release/libs/preprocessor/">Boost Preprocessor</a> and the infamous <a href="https://github.com/orangeduck/CPP_COMPLETE">Brainfuck interpreter</a> are a testament to its wide-ranging capabilities.</p>
<p>Of course, the best way to learn is to do, and I felt like indulging in some masochism. So - onwards!</p>
<span id="continue-reading"></span>
<p>Token pasting is the main (see: <em>only</em>) operation in the C preprocessor. Two tokens (input strings) are added together (concatenated); while this seems rather limited, you'll see it has plenty of potential:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdio.h</span><span>&gt;
</span><span>
</span><span style="color:#65737e;">/* The token pasting abuse that makes this possible */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">JOIN_INTERNAL</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b </span><span>) a##b
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">JOIN</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b </span><span>) </span><span style="color:#bf616a;">JOIN_INTERNAL</span><span>( a, b )
</span></code></pre>
<p>We use two macros here because our main <code>JOIN</code> macro needs to expand its arguments (which will be macros themselves!) before passing it onto <code>JOIN_INTERNAL</code> - otherwise, the macros will go through without being expanded, which will not produce the desired results.</p>
<h1 id="binary-operators">Binary Operators</h1>
<h2 id="xor">XOR</h2>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* Operators */
</span><span style="color:#65737e;">/* XOR */
</span><span style="color:#b48ead;">#define </span><span>XOR_00 </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>XOR_10 </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span>XOR_01 </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span>XOR_11 </span><span style="color:#d08770;">0
</span><span>
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">XOR</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b </span><span>) </span><span style="color:#bf616a;">JOIN</span><span>( XOR_, </span><span style="color:#bf616a;">JOIN</span><span>( a, b ) )
</span></code></pre>
<h2 id="and">AND</h2>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* AND */
</span><span style="color:#b48ead;">#define </span><span>AND_00 </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>AND_10 </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>AND_01 </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>AND_11 </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">AND</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b </span><span>) </span><span style="color:#bf616a;">JOIN</span><span>( AND_, </span><span style="color:#bf616a;">JOIN</span><span>( a, b ) )
</span></code></pre>
<p>Now, we have token pasting. We know that we can add together tokens to produce new tokens. Say we have two tokens, representing bits: <code>0</code> and <code>1</code>. If we token paste them together, we get <code>01</code>. Now, if we token paste <em>that</em> with another token, say <code>XOR_</code>, we can get <code>XOR_01</code>, which is another token.</p>
<p>We know that the preprocessor is all too happy to expand these - so what if we made a <a href="http://en.wikipedia.org/wiki/Truth_table">truth table</a> of tokens? By defining macros which correspond to our tokens (<code>XOR_00</code>, <code>XOR_01</code>, etc), the values of these macros are substituted when we token paste <code>XOR_</code>, <code>0</code>, and <code>1</code> together - we have created an operator!</p>
<p>By defining the truth table for XOR and AND, we've set up the basic building blocks that we need for our 4-bit adder.</p>
<h1 id="full-adder">Full Adder</h1>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* Full adder macros */
</span><span style="color:#65737e;">/* Out = (A ^ B) ^ cin */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">FULL_ADD_OUT</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>, </span><span style="color:#bf616a;">cin </span><span>) \
</span><span>    </span><span style="color:#bf616a;">XOR</span><span>( </span><span style="color:#bf616a;">XOR</span><span>( a, b ), cin )
</span><span>
</span><span style="color:#65737e;">/* Carry_out = (A &amp; B) ^ (Carry_in &amp; (A ^ B)) */
</span><span style="color:#65737e;">/* The standard adder uses OR for the last &#39;gate&#39; - this can safely be changed
</span><span style="color:#65737e;">   to XOR, which has been done here to avoid defining an OR operator */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">FULL_ADD_CARRY</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>, </span><span style="color:#bf616a;">cin </span><span>) \
</span><span>    </span><span style="color:#bf616a;">XOR</span><span>( </span><span style="color:#bf616a;">AND</span><span>( </span><span style="color:#bf616a;">XOR</span><span>( a, b ), cin ), </span><span style="color:#bf616a;">AND</span><span>( a, b ) )
</span></code></pre>
<p>Here lies the core of the adder. These macros transcode the logic behind the <a href="http://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder">full adder</a> - the equations have been reproduced in the comments.</p>
<p>These macros basically chain together the <code>XOR</code> and <code>AND</code> operators we made before, so that we can calculate the output and <code>Carry Out</code> bits from our input (the <code>A</code>, <code>B</code> and <code>Carry In</code> bits).</p>
<p>To calculate an addition, we call <code>FULL_ADD_OUT</code> and <code>FULL_ADD_CARRY</code> for each output bit; the parameters are the corresponding input bits, and the <code>Carry Out</code> from the last bit. Basically, we chain each full adder by its <code>Carry Out</code> output. For the first full adder, we simply pass 0 into <code>Carry In</code>.</p>
<h1 id="conversion">Conversion</h1>
<p>Binary numbers are a convenient representation for computational arithmetic, as we can see in our implementation of the full adder. Unfortunately, they're slightly less convenient for humans and compilers expecting human input. With some clever token pasting trickery, we can define conversion operators:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* Number -&gt; binary conversion */
</span><span style="color:#b48ead;">#define </span><span>NUMBER_TO_BINARY_0 </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>NUMBER_TO_BINARY_1 </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span>NUMBER_TO_BINARY_2 </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>NUMBER_TO_BINARY_3 </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1
</span><span style="color:#65737e;">/* ... To NUMBER_TO_BINARY_15 ... */
</span><span>
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">NUMBER_TO_BINARY</span><span>( </span><span style="color:#bf616a;">a </span><span>) </span><span style="color:#bf616a;">JOIN</span><span>( NUMBER_TO_BINARY_, a )
</span><span>
</span><span style="color:#65737e;">/* Binary -&gt; number conversion */
</span><span style="color:#b48ead;">#define </span><span>BINARY_TO_NUMBER_0000 </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">#define </span><span>BINARY_TO_NUMBER_0001 </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">#define </span><span>BINARY_TO_NUMBER_0010 </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">#define </span><span>BINARY_TO_NUMBER_0011 </span><span style="color:#d08770;">3
</span><span style="color:#65737e;">/* ... To BINARY_TO_NUMBER_1111 ... */
</span><span>
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BINARY_TO_NUMBER_INTERNAL</span><span>( </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>, </span><span style="color:#bf616a;">c</span><span>, </span><span style="color:#bf616a;">d </span><span>) \
</span><span>    </span><span style="color:#bf616a;">JOIN</span><span>( BINARY_TO_NUMBER_, </span><span style="color:#bf616a;">JOIN</span><span>( a, </span><span style="color:#bf616a;">JOIN</span><span>( b, </span><span style="color:#bf616a;">JOIN</span><span>( c, d ) ) ) )
</span><span>
</span><span style="color:#65737e;">/* This is necessary to expand an incoming macro into its binary
</span><span style="color:#65737e;">   form; otherwise, only one argument will be passed into the macro
</span><span style="color:#65737e;">   expecting four */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">BINARY_TO_NUMBER</span><span>( </span><span style="color:#bf616a;">x </span><span>) </span><span style="color:#bf616a;">BINARY_TO_NUMBER_INTERNAL</span><span>( x )
</span></code></pre>
<p><code>NUMBER_TO_BINARY</code> takes in a base-10 number from 0 to 15, adds it to <code>NUMBER_TO_BINARY_</code>, and then returns the appropriate token; this expands to the binary format that our adder uses.</p>
<p><code>BINARY_TO_NUMBER</code> takes in four bits, pastes them together (<code>0, 1, 1, 0</code> becomes <code>0110</code>), and then pastes that with <code>BINARY_TO_NUMBER_</code>, which expands to a normal base-10 number.</p>
<p>Of note is that there are two macros - <code>BINARY_TO_NUMBER_INTERNAL</code>, and <code>BINARY_TO_NUMBER</code>. You see, this macro suffers from the same problem as <code>JOIN</code> - it needs to expand its arguments before we can use it! <code>BINARY_TO_NUMBER</code> simply expands the arguments and passes it to <code>BINARY_TO_NUMBER_INTERNAL</code>, which produces the correct token.</p>
<h1 id="four-bit-addition">Four-Bit Addition</h1>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* Four-bit addition! Can easily be extended, but gets messy for
</span><span style="color:#65737e;">   obvious reasons */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">ADD_A_B_4BIT</span><span>( </span><span style="color:#bf616a;">a1</span><span>, </span><span style="color:#bf616a;">a2</span><span>, </span><span style="color:#bf616a;">a3</span><span>, </span><span style="color:#bf616a;">a4</span><span>, </span><span style="color:#bf616a;">b1</span><span>, </span><span style="color:#bf616a;">b2</span><span>, </span><span style="color:#bf616a;">b3</span><span>, </span><span style="color:#bf616a;">b4 </span><span>) \
</span><span>    </span><span style="color:#bf616a;">FULL_ADD_OUT</span><span>( a1, b1, \
</span><span>        </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a2, b2, \
</span><span>            </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a3, b3, \
</span><span>                </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a4, b4, </span><span style="color:#d08770;">0 </span><span>) ) ) ), \
</span><span>    \
</span><span>    </span><span style="color:#bf616a;">FULL_ADD_OUT</span><span>( a2, b2, \
</span><span>        </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a3, b3, \
</span><span>            </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a4, b4, </span><span style="color:#d08770;">0 </span><span>) ) ), \
</span><span>    \
</span><span>    </span><span style="color:#bf616a;">FULL_ADD_OUT</span><span>( a3, b3, \
</span><span>        </span><span style="color:#bf616a;">FULL_ADD_CARRY</span><span>( a4, b4, </span><span style="color:#d08770;">0 </span><span>) ), \
</span><span>    \
</span><span>    </span><span style="color:#bf616a;">FULL_ADD_OUT</span><span>( a4, b4, </span><span style="color:#d08770;">0 </span><span>) \
</span><span>
</span><span style="color:#65737e;">/* This macro receives two NUMBER macros, which expand to the 4-bits necessary
</span><span style="color:#65737e;">   for each argument */
</span><span style="color:#b48ead;">#define </span><span style="color:#8fa1b3;">ADD_A_B_4BIT_NUMBERS</span><span>( </span><span style="color:#bf616a;">n1</span><span>, </span><span style="color:#bf616a;">n2 </span><span>) </span><span style="color:#bf616a;">ADD_A_B_4BIT</span><span>( n1, n2 )
</span></code></pre>
<p>And now: four-bit addition. Looks nasty? That's because it is. This macro spits out four bits, just like our <code>NUMBER_TO_BINARY</code> macros.</p>
<p>Each bit is the result of <code>FULL_ADD_OUT</code>; as there's no way to save the <code>FULL_ADD_CARRY</code> from each bit, we deal with this problem in a questionable manner: we manually nest the <code>FULL_ADD_CARRY</code> macros. The last bit has no carry, so we set it to zero; the second-last bit has the carry from the last bit; the third-last bit has the carry from the second-last bit, which is itself defined in terms of the last bit's carry; and so on, until we reach the first bit.</p>
<p>After unpacking, we can see that this is a rather simple process that results in the 4-bit addition of the numbers we pass in. We have to wrap <code>ADD_A_B_4BIT</code> in <code>ADD_A_B_4BIT_NUMBERS</code> so that macros that we pass in, such as the <code>NUMBER</code> macros, get converted to binary. Phew!</p>
<h1 id="testing">Testing</h1>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#96b5b4;">printf</span><span>( &quot;</span><span style="color:#d08770;">%i</span><span style="color:#a3be8c;"> + </span><span style="color:#d08770;">%i</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">%i</span><span style="color:#96b5b4;">\n</span><span>&quot;,
</span><span>        NUMBER_1,
</span><span>        NUMBER_2,
</span><span>        </span><span style="color:#bf616a;">BINARY_TO_NUMBER</span><span>(
</span><span>            </span><span style="color:#bf616a;">ADD_A_B_4BIT_NUMBERS</span><span>(
</span><span>                </span><span style="color:#bf616a;">NUMBER_TO_BINARY</span><span>( NUMBER_1 ),
</span><span>                </span><span style="color:#bf616a;">NUMBER_TO_BINARY</span><span>( NUMBER_2 ) ) ) );
</span><span>}
</span></code></pre>
<p>For the conclusion, our test case. We have our standard <code>int main()</code> function, and a seemingly standard <code>printf</code> showing an addition. But wait! In lieu of actual numbers, we have <code>NUMBER_1</code>, <code>NUMBER_2</code>, and our addition macro.</p>
<p><code>NUMBER_1</code> and <code>NUMBER_2</code> aren't defined in the actual code: we provide them as a compile-time argument (via <code>-D</code>). This code is relatively simple: our two numbers are converted to binary, run through our addition macro, and the result is converted back into a number, just in time to be passed into our <code>printf</code>.</p>
<p>Time to test this sucker!</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">philpax@morningtide:$</span><span> clang full_add.c</span><span style="color:#bf616a;"> -DNUMBER_1</span><span>=7</span><span style="color:#bf616a;"> -DNUMBER_2</span><span>=4
</span><span style="color:#bf616a;">philpax@morningtide:$</span><span> ./a.out
</span><span style="color:#bf616a;">7</span><span> + 4 = 11
</span></code></pre>
<p>Ain't she a beaut?</p>
<p>And to round things out, here's the expanded version of the <code>int main()</code> function after the C preprocessor has run.</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">philpax@morningtide:$</span><span> clang</span><span style="color:#bf616a;"> -E</span><span> full_add.c</span><span style="color:#bf616a;"> -DNUMBER_1</span><span>=7</span><span style="color:#bf616a;"> -DNUMBER_2</span><span>=4
</span></code></pre>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">/* Omitted for brevity */
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#96b5b4;">printf</span><span>( &quot;</span><span style="color:#d08770;">%i</span><span style="color:#a3be8c;"> + </span><span style="color:#d08770;">%i</span><span style="color:#a3be8c;"> = </span><span style="color:#d08770;">%i</span><span style="color:#96b5b4;">\n</span><span>&quot;,
</span><span>        </span><span style="color:#d08770;">7</span><span>,
</span><span>        </span><span style="color:#d08770;">4</span><span>,
</span><span>        </span><span style="color:#d08770;">11 </span><span>);
</span><span>}
</span></code></pre>
<p>I hope you've enjoyed this brief look at the mysterious, powerful, and quite frankly <em>insane</em> C preprocessor. A compiling version of the full code can be found <a href="https://github.com/Philpax/binarycpp/tree/ec87c09088eacc2b95ff7a8b35093cb0176afdd6">here</a>. At the time of testing, this code worked in GCC and Clang, but not Visual C++.</p>


        
    

        
        
    </article></div>
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright copyright--user">Â© philpax</div>
    <script type="text/javascript" src="https://philpax.me/assets/js/main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
